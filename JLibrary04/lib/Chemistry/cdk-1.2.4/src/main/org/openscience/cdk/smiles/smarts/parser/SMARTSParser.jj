/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:/Development/JLibraries/cdk-1.2.4/src/main/org/openscience/cdk/smiles/smarts/parser\SMARTSParser.jj */
/*@egen*/options {
	STATIC=false;
	FORCE_LA_CHECK=false;
	USER_CHAR_STREAM = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;                                                                 
}

PARSER_BEGIN(SMARTSParser)

/* $RCSfile$
 * $Author: $
 * $Date: $
 * $Revision: $
 *
 * Copyright (C) 2004-2007  The Chemistry Development Kit (CDK) project
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * (or see http://www.gnu.org/copyleft/lesser.html)
 */

package org.openscience.cdk.smiles.smarts.parser;

import java.io.StringReader;
import java.util.Stack;

import org.openscience.cdk.exception.CDKException;
import org.openscience.cdk.isomorphism.matchers.QueryAtomContainer;
import org.openscience.cdk.tools.LoggingTool;

/**
 * This parser implements a nearly complete subset of the SMARTS syntax as defined on
 * <a href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">the
 * Daylight website</a>. 
 *
 * <p>Example code using SMARTS substructure search looks like:
 * <pre>
 * SmilesParser sp = new SmilesParser();
 * AtomContainer atomContainer = sp.parseSmiles("CC(=O)OC(=O)C");
 * QueryAtomContainer query = SMARTSParser.parse("C*C");
 * boolean queryMatch = UniversalIsomorphismTester.isSubgraph(atomContainer, query);
 * </pre>
 *
 * <p>See the cdk.test.smiles.smarts.parser.ParserTest for examples of the implemented
 * subset.
 *
 * This parser is based on JJTree and it generates an AST (Abstract Syntax Tree)
 * <p>To get the AST, the code looks like:
 * <pre>
 * SMARTSParser parser = new SMARTSParser(new java.io.StringReader("C*C"));
 * ASTStart = parser.start();
 * </pre>
 *
 * @see org.openscience.cdk.isomorphism.matchers.smarts.SMARTSAtom
 *
 * @author      Dazhi Jiao
 * @cdk.created 2007-04-23
 * @cdk.githash
 *
 * @cdk.require ant1.6
 * @cdk.module  smarts
 *
 * @cdk.keyword SMARTS
 * @cdk.keyword substructure search
 */
public class SMARTSParser/*@bgen(jjtree)*/implements SMARTSParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSMARTSParserState jjtree = new JJTSMARTSParserState();

/*@egen*/

	/**
	 * This method parses a Smarts String and returns an instance of 
	 * <code>QueryAtomContainer</code>
	 */
	public static QueryAtomContainer parse(String smarts) throws CDKException {
        QueryAtomContainer container = null;
        StringReader reader = new StringReader(smarts);
        try {
            SMARTSParser parser = new SMARTSParser(reader);
            ASTStart start = parser.Start();
            org.openscience.cdk.smiles.smarts.parser.visitor.SmartsQueryVisitor visitor 
            	= new org.openscience.cdk.smiles.smarts.parser.visitor.SmartsQueryVisitor();
            container = (QueryAtomContainer)start.jjtAccept(visitor, null);
        } catch (ParseException exception) {
            throw new CDKException("The string " + smarts + " is not a valid" +
              " SMARTS string: " + exception.getMessage(), exception);
        }
        return container;	
	} 
}

PARSER_END(SMARTSParser)

<*> TOKEN:
{
    <#_WS: ( " " | "\t" | "\n" | "\r" ) >
}

<DEFAULT> TOKEN:
{
    // Logical Operators
    <L_AND : ";" >
    |
    <H_AND : "&" >
    |
    <OR    : "," >
    |
    <NOT   : "!" >
    |
    // Bond
    <   S_BOND : "-" >  // single bond 
    |
    <UP_S_BOND : "/" >  // directional single bond "up"
    |
    <DN_S_BOND : "\\" > // directional sinble bond "down"
    |
    <UP_OR_UNSPECIFIED_S_BOND : "/?" > 
    |
    <DN_OR_UNSPECIFIED_S_BOND : "\\?" >
    |
    <   D_BOND : "=" >  // double bond
    |
    <   T_BOND : "#" >  // triple bond
    |
    <   AR_BOND : ":" >  // aromatic bond
    |
    < ANY_BOND : "~" >  // any bond
    |
    <   R_BOND : "@" >  // any ring bond
    |
    // Elements
        <  c: "c" >
    |   <  n: "n" >
    |   <  o: "o" >
    |   <  s: "s" >
    |   <  p: "p" >
    |   < as: "as" >
    |   < se: "se" >
    |   <  H: "H" >
    |   < HE: "He" >
    |   < LI: "Li" >
    |   < BE: "Be" >
    |   <  B: "B" >
    |   <  C: "C" >
    |   <  N: "N" >
    |   <  O: "O" >
    |   <  F: "F" >
    |   < NE: "Ne" >
    |   < NA: "Na" >
    |   < MG: "Mg" >
    |	< AL: "Al" >
    |	< SI: "Si" >
    |   <  P: "P" >
    |   <  S: "S" >
    |	< CL: "Cl" >
    |	< AR: "Ar" >
    |   <  K: "K" >
    |   < CA: "Ca" >
    |   < SC: "Sc" >
    |   < TI: "Ti" >
    |   <  V: "V" >
    |   < CR: "Cr" >
    |   < MN: "Mn" >
    |   < FE: "Fe" >
    |   < CO: "Co" >
    |   < NI: "Ni" >
    |   < CU: "Cu" >
    |   < ZN: "Zn" >
    |   < GA: "Ga" >
    |   < GE: "Ge" >
    |   < AS: "As" >
    |   < SE: "Se" >
    |   < BR: "Br" >
    |   < KR: "Kr" >
    |   < RB: "Rb" >
    |   < SR: "Sr" >
    |   <  Y: "Y" >
    |   < ZR: "Zr" >
    |   < NB: "Nb" >
    |   < MO: "Mo" >
    |   < TC: "Tc" >
    |   < RU: "Ru" >
    |   < RH: "Rh" >
    |   < PD: "Pd" >
    |   < AG: "Ag" >
    |   < CD: "Cd" >
    |   < IN: "In" >
    |   < SN: "Sn" >
    |   < SB: "Sb" >
    |   < TE: "Te" >
    |   <  I: "I" >
    |   < XE: "Xe" >
    |   < CS: "Cs" >
    |   < BA: "Ba" >
    |   < LA: "La" >
    |   < HF: "Hf" >
    |   < TA: "Ta" >
    |   <  W: "W" >
    |   < RE: "Re" >
    |   < OS: "Os" >
    |   < IR: "Ir" >
    |   < PT: "Pt" >
    |   < AU: "Au" >
    |   < HG: "Hg" >
    |   < TL: "Tl" >
    |   < PB: "Pb" >
    |   < BI: "Bi" >
    |   < PO: "Po" >
    |   < AT: "At" >
    |   < RN: "Rn" >
    |   < FR: "Fr" >
    |   < RA: "Ra" >
    |   < AC: "Ac" >
    |   < TH: "Th" >
    |   < PA: "Pa" >
    |   <  U: "U" >
    |   < PU: "Pu" >
    |   < AM: "Am" >
    |   < CM: "Cm" >
    |   < BK: "Bk" >
    |   < CF: "Cf" >
    |   < ES: "Es" >
    |   < FM: "Fm" >
    |   < MD: "Md" >
    |   < NO: "No" >
    |   < LR: "Lr" >
    |   <  NP: "Np" >
    |   <  CE: "Ce" >
    |   <  ND: "Nd" >
    |   <  PM: "Pm" >
    |   <  SM: "Sm" >
    |   <  EU: "Eu" >
    |   <  GD: "Gd" >
    |   <  TB: "Tb" >
    |   <  DY: "Dy" >
    |   <  HO: "Ho" >
    |   <  ER: "Er" >
    |   <  TM: "Tm" >
    |   <  YB: "Yb" >
    |   <  LU: "Lu" >
    |   <  PR: "Pr" >        
    // Atomic Primitives
    |   < WILDCARD: "*" >
    |
    <h : "h" >
    |
    <a : "a" >
    |
    <A : "A" >
    |
    <D : "D" >
    |
    <R : "R" >
    |
    <r : "r" >
    |
    <v : "v" >
    |
    <X : "X" >
    |
    <x : "x" >
    |
    <G : "G" >
    |
    <HX : "#X" >
    |
    <CARET : "^">
    |
    <DOLLAR : "$" >
    |
    <L_PAREN : "(" >
    | 
    <R_PAREN : ")" >
    |
    <L_BRACKET : "[" >
    |
    <R_BRACKET : "]" >
    |
    <Q_MARK : "?" >
    |
    <DIGIT: ["0"-"9"] > 
}

/**
 *                     Start ::= <ReactionExpression>
 *        ReactionExpression ::= <GroupExpression> (">>" <GroupExpression>)? |
 *                               ">" <GroupExpression> ">" | ">>" <GroupExpression>
 *           GroupExpression ::= ["("] <SmartsExpresion> [")"] ( "." ["("] <SmartsExpression> [")"] )*
 *          SmartsExpression ::= <AtomExpression> ( 
 									( [ <LowAndBond> ] ( <Digit> | <AtomExpression> ) ) |
 									( "(" [ <LowAndBond> ] <SmartsExpression> ")" ) )*
 		      AtomExpression ::= ( "[" [ <AtomicMass> ] <LowAndExpression> "]" ) | <ExplicitAtomExpression>
 *                LowAndBond ::= <OrBond> [ ";" <AndBond> ]
 *                    OrBond ::= <ExplicitHighAndBond> [ "," <OrBond> ]
 *       ExplicitHighAndBond ::= <ImplicitHighAndBond> [ "&" <ExplicitHighAndBond> ]
 *       ImplicitHighAndBond ::= <NotBond> [ <ImplicitHighAndBond> ]
 *                   NotBond ::= [ "!" ] <SimpleBond>
 *                SimpleBond ::= "/" | "\\" | "/?" | "\\?" | "=" | "#" | "~" | "@"
 *    ExplicitAtomExpression ::= [ "B" | "C" | "N" | "O" | "P" | "S" | "F" | "CL" | "BR" | "I" 
 *                               | "c" | "o" | "n" | "*" | "A" | "a" | "p" | "as" | "se" ] 
 *          LowAndExpression ::= <OrExpression> ( ";" <LowAndExpression> )?
 *              OrExpression ::= <ExplicitHighAndExpression> ( "," <OrExpression> ) ?
 * ExplicitHighAndExpression ::= <ImplicitHighAndExpression> ( "&" <ExplicitHighAndExpression> )?
 * ImplicitHighAndExpression ::= <NotExpression> ( <ImplicitHighAndExpression> ) ?
 *             NotExpression ::= "!" ( <PrimitiveAtomExpression> | <RecursiveSmartsExpression> )
 * RecursiveSmartsExpression ::= "$" "(" <SmartsExpression> ")"
 *   PrimitiveAtomExpression ::= <NonHydrogenElement> | "*" | "A" | "a" | "D" (<Digits>)? | "H" (<Digits>)? | "h" (<Digits>)?
 *                               | "R" (<Digit>+)? | "r" (<Digit>+)? | "v" (<Digit>+)? | "#X" | "G" (<DIGIT>+)  
 *                               | "X" (<Digit>+)? | "x" (<Digit>+)? | "^" (<DIGIT>)
 *                               | ("+" | "-") (<Digit>+)? | "#" (<Digit>+) | "@" | "@@" | <Digit>+
 *                     Digit ::= ( "0" - "9")
 *        NonHydrogenElement ::= [ "HE" | "LI" | "BE" | "NE" | "NA" | "MG" | "AL" | "SI" | "AR" | "CA" | "SC" |
 *                               "TI" | "CR" | "MN" | "FE" | "CO" | "NI" | "CU" | "ZN" | "GA" | "GE" | "AS" |
 *                               "SE" | "BR" | "KR" | "RB" | "SR" | "ZR" | "NB" | "MO" | "TC" | "RU" | "RH" |
 *                               "PD" | "AG" | "CD" | "IN" | "SN" | "SB" | "TE" | "XE" | "CS" | "BA" | "LA" |
 *                               "HF" | "TA" | "RE" | "OS" | "IR" | "PT" | "AU" | "HG" | "TL" | "PB" | "BI" |
 *                               "PO" | "AT" | "RN" | "FR" | "RA" | "AC" | "TH" | "PA" |
 *                               "B" | "C" | "N" | "O" | "F" | "P" | "S" | "K" | "V" | "Y" | "I" | "U" |
 *                               "c" | "o" | "n" | "p" | "as" | "se" ]
 */

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    ReactionExpression() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReactionExpression()           : {/*@bgen(jjtree) Reaction */
  ASTReaction jjtn000 = new ASTReaction(JJTREACTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Reaction */
    try {
/*@egen*/
    GroupExpression() ( ">>" [GroupExpression()] )?
    |
    ">" GroupExpression() ">"
    |
    ">>" GroupExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GroupExpression()        : {/*@bgen(jjtree) Group */
                                  ASTGroup jjtn000 = new ASTGroup(JJTGROUP);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/ ASTSmarts smarts; }
{/*@bgen(jjtree) Group */
    try {
/*@egen*/
    [<L_PAREN>] SmartsExpression() [<R_PAREN>] 
    ( "." 
    	[<L_PAREN>] SmartsExpression() [<R_PAREN>] 
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

void SmartsExpression()         : 
{/*@bgen(jjtree) Smarts */
        ASTSmarts jjtn000 = new ASTSmarts(JJTSMARTS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	ASTAtom atom; 
}
{/*@bgen(jjtree) Smarts */
        try {
/*@egen*/
	atom = AtomExpression() 
	(
	  (
	  	( LowAndBond() )? 
	  	( 
	  		<DIGIT>
	  		{
	  			ASTLowAndBond bond = null;
				ASTRingIdentifier ringId = new ASTRingIdentifier(JJTRINGIDENTIFIER);
				if (jjtree.peekNode() instanceof ASTLowAndBond) {
					bond = (ASTLowAndBond)jjtree.popNode(); // pop the bond
					ringId.jjtAddChild(bond, 0);
				}
				ringId.setRingId(Integer.parseInt(token.image));
				atom.jjtAddChild(ringId, atom.jjtGetNumChildren());
	  		} 
	  		| 
	  		atom = AtomExpression()
	  	)
	  ) 
	  |
	  ( <L_PAREN> ( LowAndBond() )? SmartsExpression() <R_PAREN> ) 
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

ASTAtom	 AtomExpression()       : 
{/*@bgen(jjtree) Atom */
        ASTAtom jjtn000 = new ASTAtom(JJTATOM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token firstToken;
	Token secondToken;
	Token rightBracket;
	ASTAtomicMass massNode = null;
}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	( 
	    ( 
	    
	    	<L_BRACKET> { firstToken = getToken(1); secondToken = getToken(2); }
	    	( AtomicMass() { massNode = (ASTAtomicMass)jjtree.popNode(); }	)?
	    	LowAndExpression() 
	    	{
				if (massNode != null) { // insert AtomicMass node into expression       
					ASTLowAndExpression topNode = (ASTLowAndExpression)jjtree.popNode();
					topNode.insertLeafChild(massNode);
					jjtree.pushNode(topNode);
				}
	    	}
	    	<R_BRACKET> { rightBracket = token; }
	    	{   
	    		Token HToken = null;
	    		// If the LowAndExpression is "[H]", change it to an ExplicitAtom
	    		if (firstToken.image.equals("H")) {
	    			HToken = firstToken;
	    		} else if (massNode != null && massNode.getMass() <= 3 && secondToken != null && secondToken.image.equals("H")) {
	    			HToken = secondToken;
	    		}
	    		if (HToken != null) {
		    		if ( (rightBracket.beginColumn - HToken.endColumn) == 1) {
		    			jjtree.popNode();
		    			ASTExplicitAtom explicitAtom = new ASTExplicitAtom(JJTEXPLICITATOM);
                        if (massNode!= null) {
						    if (massNode.getMass() == 2) explicitAtom.setSymbol("D");
						    else if (massNode.getMass() == 3) explicitAtom.setSymbol("T");
						    else if (massNode.getMass() == 1) explicitAtom.setSymbol("H");
						    } else {
						      explicitAtom.setSymbol("H");
						    }
						jjtree.pushNode(explicitAtom);
		    		}
	    		}
	    	}
	    ) 
	    | 
	    ExplicitAtomExpression() 
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LowAndBond()             : {/*@bgen(jjtree) LowAndBond */
  ASTLowAndBond jjtn000 = new ASTLowAndBond(JJTLOWANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowAndBond */
    try {
/*@egen*/
    OrBond() ( <L_AND> LowAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrBond()         : {/*@bgen(jjtree) OrBond */
  ASTOrBond jjtn000 = new ASTOrBond(JJTORBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrBond */
    try {
/*@egen*/
    ExplicitHighAndBond() ( <OR> OrBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitHighAndBond()                      : {/*@bgen(jjtree) ExplicitHighAndBond */
  ASTExplicitHighAndBond jjtn000 = new ASTExplicitHighAndBond(JJTEXPLICITHIGHANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitHighAndBond */
    try {
/*@egen*/
    ImplicitHighAndBond() ( <H_AND> ExplicitHighAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHighAndBond()                      : {/*@bgen(jjtree) ImplicitHighAndBond */
  ASTImplicitHighAndBond jjtn000 = new ASTImplicitHighAndBond(JJTIMPLICITHIGHANDBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplicitHighAndBond */
    try {
/*@egen*/
    NotBond() ( ImplicitHighAndBond() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotBond()          : {/*@bgen(jjtree) NotBond */
  ASTNotBond jjtn000 = new ASTNotBond(JJTNOTBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotBond */
    try {
/*@egen*/
    [ <NOT> { jjtn000.setType(SMARTSParserConstants.NOT); } ] SimpleBond()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}
void SimpleBond()             : {/*@bgen(jjtree) SimpleBond */
  ASTSimpleBond jjtn000 = new ASTSimpleBond(JJTSIMPLEBOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleBond */
    try {
/*@egen*/
    (
        LOOKAHEAD(2)
        <S_BOND> 
        | 
        <UP_S_BOND> // TODO: Need API
        | 
        <DN_S_BOND> // TODO: Need API
        | 
        <UP_OR_UNSPECIFIED_S_BOND> // TODO: Need API
        | 
        <DN_OR_UNSPECIFIED_S_BOND> // TODO: Need API
        | 
        <D_BOND> 
        | 
        <T_BOND> 
        | 
        <AR_BOND> 
        | 
        <ANY_BOND> 
        | 
        <R_BOND>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setBondType(token.kind);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitAtomExpression()               : {/*@bgen(jjtree) ExplicitAtom */
  ASTExplicitAtom jjtn000 = new ASTExplicitAtom(JJTEXPLICITATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitAtom */
    try {
/*@egen*/
    ( <B> | <C> | <N> | <O> | <P> | <S> | <F> | <CL> | <BR> | <I> | <WILDCARD> | <A> | <a> | <c> | <n> | <o> | <s> | <p> | <se> | <as>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setSymbol(token.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// TODO: This requires a fully implemented SMARTSAtom API (or something else) that 
// could encapsulate logical criterias
void LowAndExpression()                   : {/*@bgen(jjtree) LowAndExpression */
  ASTLowAndExpression jjtn000 = new ASTLowAndExpression(JJTLOWANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LowAndExpression */
    try {
/*@egen*/
    OrExpression() ( <L_AND> LowAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void OrExpression()               : {/*@bgen(jjtree) OrExpression */
  ASTOrExpression jjtn000 = new ASTOrExpression(JJTOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrExpression */
    try {
/*@egen*/
    ExplicitHighAndExpression() ( <OR> OrExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitHighAndExpression()                            : {/*@bgen(jjtree) ExplicitHighAndExpression */
  ASTExplicitHighAndExpression jjtn000 = new ASTExplicitHighAndExpression(JJTEXPLICITHIGHANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitHighAndExpression */
    try {
/*@egen*/
    ( ImplicitHighAndExpression() ) ( <H_AND> ExplicitHighAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHighAndExpression()                            : {/*@bgen(jjtree) ImplicitHighAndExpression */
  ASTImplicitHighAndExpression jjtn000 = new ASTImplicitHighAndExpression(JJTIMPLICITHIGHANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplicitHighAndExpression */
    try {
/*@egen*/
    NotExpression() ( ImplicitHighAndExpression() ) ?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/  
}

void NotExpression()                : 
{/*@bgen(jjtree) NotExpression */
  ASTNotExpression jjtn000 = new ASTNotExpression(JJTNOTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ jjtn000.setType(SMARTSParserConstants.DEFAULT); }
{/*@bgen(jjtree) NotExpression */
    try {
/*@egen*/
    [ <NOT> { jjtn000.setType(SMARTSParserConstants.NOT); } ] 
    ( PrimitiveAtomExpression() | RecursiveSmartsExpression() )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RecursiveSmartsExpression()                            : {/*@bgen(jjtree) RecursiveSmartsExpression */
  ASTRecursiveSmartsExpression jjtn000 = new ASTRecursiveSmartsExpression(JJTRECURSIVESMARTSEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RecursiveSmartsExpression */
    try {
/*@egen*/
    <DOLLAR> <L_PAREN> SmartsExpression() <R_PAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrimitiveAtomExpression() : {}
{
    (
        NoHydrogenElement() 
        |
        AnyAtom()
        |
        Aromatic()
        |
        Aliphatic()
        |
        ExplicitConnectivity()
        |
        TotalHCount()
        |
        ImplicitHCount()
        |
        RingMembership()
        |
        SmallestRingSize()
        |
        Valence()
        |
        TotalConnectivity()
        |
        RingConnectivity()
        |
        Charge()
        |
        AtomicNumber()
        |
        Chirality()
        |
        PeriodicGroupNumber()
        |
        NonCHHeavyAtom()
        |
        HybridizationNumber()
    )
}

void TotalHCount()              : 
{/*@bgen(jjtree) TotalHCount */
  ASTTotalHCount jjtn000 = new ASTTotalHCount(JJTTOTALHCOUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) TotalHCount */
    try {
/*@egen*/
    <H> { jjtn000.setCount(1); } [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setCount( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImplicitHCount()                : 
{/*@bgen(jjtree) ImplicitHCount */
  ASTImplicitHCount jjtn000 = new ASTImplicitHCount(JJTIMPLICITHCOUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) ImplicitHCount */
    try {
/*@egen*/
    <h> { jjtn000.setCount(1); } [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setCount( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitConnectivity()                       : 
{/*@bgen(jjtree) ExplicitConnectivity */
  ASTExplicitConnectivity jjtn000 = new ASTExplicitConnectivity(JJTEXPLICITCONNECTIVITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) ExplicitConnectivity */
    try {
/*@egen*/
    <D> { jjtn000.setNumOfConnection(1); } 
    [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setNumOfConnection( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AtomicNumber()               : 
{/*@bgen(jjtree) AtomicNumber */
  ASTAtomicNumber jjtn000 = new ASTAtomicNumber(JJTATOMICNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) AtomicNumber */
    try {
/*@egen*/
    "#" ( <DIGIT> { digits.append(token.image); } )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    { jjtn000.setNumber( Integer.parseInt(digits.toString()) ); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void HybridizationNumber()                     :
{/*@bgen(jjtree) HybrdizationNumber */
  ASTHybrdizationNumber jjtn000 = new ASTHybrdizationNumber(JJTHYBRDIZATIONNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HybrdizationNumber */
    try {
/*@egen*/
    <CARET> ( <DIGIT> )/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {
        int tmp = Integer.parseInt(token.image);
        if (tmp < 1 || tmp > 8) throw new ParseException("Hybridization number must be between 1 & 8");
        jjtn000.setHybridizationNumber(tmp);
   }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
        
void Charge()         : 
{/*@bgen(jjtree) Charge */
  ASTCharge jjtn000 = new ASTCharge(JJTCHARGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) Charge */
    try {
/*@egen*/
    // Here assuming nobody will write anything like -----------... 
    // with more than 8 of them
    LOOKAHEAD(2)
    "+" { jjtn000.setPositive(true); jjtn000.setCharge(1); } 
      [ ( <DIGIT> { digits.append(token.image); } )+ 
      { jjtn000.setCharge( Integer.parseInt(digits.toString()) ); } ]
    | "-" { jjtn000.setPositive(false); jjtn000.setCharge(1); } 
      [ ( <DIGIT> { digits.append(token.image); } )+ 
      { jjtn000.setCharge( Integer.parseInt(digits.toString()) ); } ]
    | "--"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/          { jjtn000.setPositive(false); jjtn000.setCharge(2); }
    | "---"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/         { jjtn000.setPositive(false); jjtn000.setCharge(3); }
    | "----"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/        { jjtn000.setPositive(false); jjtn000.setCharge(4); }
    | "-----"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/       { jjtn000.setPositive(false); jjtn000.setCharge(5); }
    | "------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/      { jjtn000.setPositive(false); jjtn000.setCharge(6); }
    | "-------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/     { jjtn000.setPositive(false); jjtn000.setCharge(7); } 
    | "--------"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/    { jjtn000.setPositive(false); jjtn000.setCharge(8); }
    | "++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/          { jjtn000.setPositive(true); jjtn000.setCharge(2); }   
    | "+++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/         { jjtn000.setPositive(true); jjtn000.setCharge(3); }
    | "++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/        { jjtn000.setPositive(true); jjtn000.setCharge(4); }
    | "+++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/       { jjtn000.setPositive(true); jjtn000.setCharge(5); }
    | "++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/      { jjtn000.setPositive(true); jjtn000.setCharge(6); }
    | "+++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/     { jjtn000.setPositive(true); jjtn000.setCharge(7); }
    | "++++++++"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/    { jjtn000.setPositive(true); jjtn000.setCharge(8); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void RingConnectivity()                   : {/*@bgen(jjtree) RingConnectivity */
  ASTRingConnectivity jjtn000 = new ASTRingConnectivity(JJTRINGCONNECTIVITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RingConnectivity */
    try {
/*@egen*/
    <x> { jjtn000.setNumOfConnection(1); } 
    [ ( <DIGIT> )+ { jjtn000.setNumOfConnection( Integer.parseInt(token.image) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PeriodicGroupNumber() throws ParseException                      :
{/*@bgen(jjtree) PeriodicGroupNumber */
  ASTPeriodicGroupNumber jjtn000 = new ASTPeriodicGroupNumber(JJTPERIODICGROUPNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) PeriodicGroupNumber */
    try {
/*@egen*/
    <G> { }
    ( <DIGIT> { digits.append(token.image); } )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { int tmpInt = Integer.parseInt(digits.toString());
      if (tmpInt < 1 || tmpInt > 18) throw new ParseException("Invalid group number");
      jjtn000.setGroupNumber( Integer.parseInt(digits.toString()) ); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void TotalConnectivity()                    : 
{/*@bgen(jjtree) TotalConnectivity */
  ASTTotalConnectivity jjtn000 = new ASTTotalConnectivity(JJTTOTALCONNECTIVITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) TotalConnectivity */
    try {
/*@egen*/
    <X> { jjtn000.setNumOfConnection(1); } 
    [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setNumOfConnection( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Valence()          : 
{/*@bgen(jjtree) Valence */
  ASTValence jjtn000 = new ASTValence(JJTVALENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) Valence */
    try {
/*@egen*/
    <v> { jjtn000.setOrder(1); } 
    [ ( <DIGIT> { digits.append(token.image); })+ 
    { jjtn000.setOrder( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RingMembership()                 : 
{/*@bgen(jjtree) RingMembership */
  ASTRingMembership jjtn000 = new ASTRingMembership(JJTRINGMEMBERSHIP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) RingMembership */
    try {
/*@egen*/
    <R> { jjtn000.setNumOfMembership(1); } 
    [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setNumOfMembership( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SmallestRingSize()                   : 
{/*@bgen(jjtree) SmallestRingSize */
  ASTSmallestRingSize jjtn000 = new ASTSmallestRingSize(JJTSMALLESTRINGSIZE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) SmallestRingSize */
    try {
/*@egen*/
    <r> { jjtn000.setSize(1); } 
    [ ( <DIGIT> { digits.append(token.image); } )+ 
    { jjtn000.setSize( Integer.parseInt(digits.toString()) ); } ]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Aliphatic()            : {/*@bgen(jjtree) Aliphatic */
  ASTAliphatic jjtn000 = new ASTAliphatic(JJTALIPHATIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Aliphatic */
    try {
/*@egen*/
    <A>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void NonCHHeavyAtom()                 : {/*@bgen(jjtree) NonCHHeavyAtom */
  ASTNonCHHeavyAtom jjtn000 = new ASTNonCHHeavyAtom(JJTNONCHHEAVYATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NonCHHeavyAtom */
    try {
/*@egen*/
    <HX>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Aromatic()           : {/*@bgen(jjtree) Aromatic */
  ASTAromatic jjtn000 = new ASTAromatic(JJTAROMATIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Aromatic */
    try {
/*@egen*/
    <a>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AnyAtom()          : {/*@bgen(jjtree) AnyAtom */
  ASTAnyAtom jjtn000 = new ASTAnyAtom(JJTANYATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnyAtom */
    try {
/*@egen*/
    <WILDCARD>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AtomicMass()             : 
{/*@bgen(jjtree) AtomicMass */
  ASTAtomicMass jjtn000 = new ASTAtomicMass(JJTATOMICMASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) AtomicMass */
    try {
/*@egen*/
    ( <DIGIT> { digits.append(token.image); } )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    	jjtn000.setMass( Integer.parseInt(digits.toString()) ); 
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RingIdentifier()                : {/*@bgen(jjtree) RingIdentifier */
  ASTRingIdentifier jjtn000 = new ASTRingIdentifier(JJTRINGIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RingIdentifier */
        try {
/*@egen*/
	LowAndBond() <DIGIT>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Chirality()            : 
{/*@bgen(jjtree) Chirality */
  ASTChirality jjtn000 = new ASTChirality(JJTCHIRALITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuffer digits = new StringBuffer(); }
{/*@bgen(jjtree) Chirality */
    try {
/*@egen*/
    LOOKAHEAD(2)
    "@"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ { jjtn000.setClockwise(true); } | "@@" { jjtn000.setClockwise(false); }
    ( 
    	( <DIGIT> { digits.append(token.image); } )+
    	{
    		jjtn000.setDegree( Integer.parseInt(digits.toString()) );
    	}
    )? 
    ( 
    	<Q_MARK> { jjtn000.setUnspecified(true); }
    )?/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NoHydrogenElement()         : {/*@bgen(jjtree) Element */
  ASTElement jjtn000 = new ASTElement(JJTELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Element */
        try {
/*@egen*/
	(
    <HE> | <LI> | <BE> | <NE> | <NA> | <MG> | <AL> | <SI> | <AR> | <CA> | <SC> |
    <TI> | <CR> | <MN> | <FE> | <CO> | <NI> | <CU> | <ZN> | <GA> | <GE> | <AS> |
    <SE> | <BR> | <KR> | <RB> | <SR> | <ZR> | <NB> | <MO> | <TC> | <RU> | <RH> |
    <PD> | <AG> | <CD> | <IN> | <SN> | <SB> | <TE> | <XE> | <CS> | <BA> | <LA> |
    <HF> | <TA> | <W>  | <RE> | <OS> | <IR> | <PT> | <AU> | <HG> | <TL> | <PB> | 
    <BI> | <PO> | <AT> | <RN> | <FR> | <RA> | <AC> | <TH> | <PA> | <CL> |
	<B> | <C> | <N> | <O> | <F> | <P> | <S> | <K> | <V> | <Y> | <I> | <U> | 
    <c> | <o> | <n> | <s> | <p> | <as> | <se> | <PU> | <AM> | <CM> | <BK> | <CF> |
    <ES> | <FM> | <MD> | <NO> | <LR>  | <NP>   | <CE>   | <ND>   | <PM>   | <SM>  |
    <EU>   | <GD>   | <TB>   | <DY>   | <HO>   | <ER>   | <TM>   | <YB>   | <LU>   | <PR>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setSymbol(token.image);
    }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
